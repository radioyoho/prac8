Sistema de archivos 

Estructura de datos -> Nodo i / i-Node
Contiene: Nombre del archivo, datos sobre el dueño del archivo(usrid)16bit, gid(grupo del dueño del archivo)16bit, fecha y hora de creacion32bit
	Fecha y hora de modificacion32bit(6 bits-segundos,6 bits-minutos, 5 bits-horas, 5 bits-dias, 4 bits-mes, 6 bits-desplazamiento año).
	4-bytes para el tamaño de archivo, apuntador directo2(apunta a un bloque de datos,dos sectores), apuntador directo 2(apunta a un bloque de datos,dos sectos)
	Cada apuntador mide 2Bytes, al final hay un apuntador indirecto, el cual apunta a un bloque donde se guardan 512 apuntadores a bloques.
	apuntador indirecto doble, apunta a otro bloque con 512 apuntadores, donde cada apuntador de ese bloque apunta a bloques con 512 apuntadores
	
Un i-Node tiene hasta 10 apuntadores directos, maximo tamaño de archivo de 10KB

Tamaño de un i-Node 64 Bytes, buscar que siempre este en potencias de 2
En cada sector logico se puede tener hasta 8 i-nodes, el directorio raiz va a tener 24 i-nodes
Cada bit del sector logico 1 se va a referir a un i-node, indica con 0 o 1 si el i-node esta libre u ocupado
A partir del sector logico 11 hasta el 12 se encuentra el Bloque 1, cada dos sectores se encuentra un bloque 

Sectores logicos de l 2 al 7 son bits que indican los bloques libres y los bloques ocupados

43188 sectores, con 2 sectores por bloque , 21594 bloques para el sistema de archivos. 

Nota, los bloques pueden variar, en nuestro sistemas de archivos los bloques son de 2 sectores, 1kB.


struct SECBOOTPART{
	char jump[4];
	char nombre_particion[8];
	//Tabla de parametros del bios
	//Estan los datos sobre el formato 
	
	unsigned short sec_inicpart;
	unsigned 
	
	
struct INODE{
	char name[18];
	unsigned int datecreat
	unsigned int datemod
	unsigned int dateacc
	unsigend short uid
	unsigned short gid
	unsigned short perms
	unsigned int size
	unsigned short direct_blocks
}
Permisos. (Cada permiso es 1 bit)
	Dueño:RWX 
	Grupo:RWX 
	Otros:RWX
	
vdwriteseclog(int seclog, char *buffer){
	//Calculr a partir del sector logico 
	//-cilindro
	//superficie
	//sector fisico
	vdwritesector(0,supierficie,cilindro,sector_f,1,buffer);
}
vdreadseclog(int seclog,char *buffer){
	//Calcular a partir del sector logico
	
	vdreadsector(0,superficie,cilindro,sector_f,1,buffer);
}

//funciones para la lectur y escritura de bloques. 

int writeblock(int nblock, char *buffer){
	int slad;
	int secs_x_bloque;
	int i;
	//obtener los datos del sector de boot de la particion para:
	//1-determinar en que sector inicia el area de datos
	//2-Obtener el numero de sectores por bloque y guardarlo en la variable secs_x_bloque
	//Calcular en que sector logico inicia el bloque
	seclog = slad+(nblock-1)*sec_x_bloque;
	
	//Escribir en todos los sectores logicos del bloque
	for(i = 0; i < secs_x_bloque; i++){
		vdwriteseclog(seclog,buffer);
		seclog++;
		buffer+=512;
	}
}


int readblock(int nblock, char *buffer){
	int slad;
	int secs_x_bloque;
	int i;
	//obtener los datos del sector de boot de la particion para:
	//1-determinar en que sector inicia el area de datos
	//2-Obtener el numero de sectores por bloque y guardarlo en la variable secs_x_bloque
	//Calcular en que sector logico inicia el bloque
	seclog = slad+(nblock-1)*sec_x_bloque;
	
	//Escribir en todos los sectores logicos del bloque
	for(i = 0; i < secs_x_bloque; i++){
		vdreadseclog(seclog,buffer);
		seclog++;
		buffer+=512;
	}
}

//Progama para formatear la particion con el sistema de archivos
//formatear la particion consisten en:
	1.- Poner en el sector de boot de la particion los datos de la tabla de parametros, escribirlo 
	en el sector logico 0 de la particion
	2.- Limpiar el mapa de bits del area de Nodos-i, es decir, inicializar en 0
	3.- Inicializar el mapa de bits del area de datos, es decir, inicializar en 0's excepto el primer byte donde vamos a 
	poner un 1 para tener el bloque 0 como reservado.

Escribir sbp, 
vdwriteseclog(0, (char *)&spb);

El valor de 0 se utiliza en los bloques para indicar que es nulo 

//Para manipular el mapa de bits es necesario tenerlo cargado en memoria RAM y para cargarlo a memoria RAM necesitamos saber 
//en que sectores logicos de la particion esta, y ese calculo solo lo podemos hacer con los datos que estan en el sector
//de boot de la particion
	


#include <unistdi.h>
#include <fcntl.h>

0 - STDIN archivo de entrada estandar, a travez de la consola
1 - STDOUT archivo de salida estandar, a travez de la consola (Buffered)
2 - STDERR archivo de salida estandar, envio de mensajes de error(consola)(Non-buffered)

